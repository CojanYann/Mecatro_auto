# 3. DÉVELOPPEMENT DU CODE EMBARQUÉ

Cette section présente l'implémentation concrète du code embarqué sur le Raspberry Pi Pico WH, en détaillant les modules développés pour la gestion des capteurs, la navigation automatique et les cycles fonctionnels du robot Magnéo.

## 3.1 Gestion des capteurs

### 3.1.1 Module GPS (lecture_gps_fct.py)

Le module GPS constitue l'un des éléments essentiels du système de navigation automatique. Il assure la lecture des coordonnées géographiques et leur conversion dans un format exploitable par les algorithmes de navigation.

#### Configuration UART

La communication avec le module GPS s'effectue via l'interface UART configurée sur les pins 0 et 1 du Pico WH :

```python
# Configuration UART pour GPS
uart = UART(0, baudrate=9600, tx=Pin(0), rx=Pin(1))
```

Cette configuration utilise un débit de 9600 bauds, standard pour la plupart des modules GPS NMEA. Le choix des pins 0 et 1 permet d'utiliser l'UART0 matériel du Pico, garantissant une communication stable et fiable.

#### Conversion de coordonnées

Le module intègre une fonction de conversion des coordonnées du format degrés-minutes-décimales (utilisé par les trames NMEA) vers le format décimal exploitable par les algorithmes de calcul :

```python
def convert_to_decimal(coord_str, direction):
    if not coord_str or not direction:
        return None
    
    # Conversion degrés-minutes vers décimal
    degrees = int(coord_str[:2]) if len(coord_str) >= 4 else 0
    minutes = float(coord_str[2:]) if len(coord_str) > 2 else 0.0
    decimal = degrees + minutes / 60.0
    
    # Application direction (N/S pour latitude, E/W pour longitude)
    if direction in ['S', 'W']:
        decimal = -decimal
    
    return decimal
```

Cette fonction traite les trames NMEA standard en extrayant les degrés et minutes, puis convertit le tout en coordonnées décimales avec gestion des directions cardinales.

#### Gestion timeout et erreurs

Le module implémente une gestion robuste des erreurs avec timeout pour éviter les blocages :

```python
def read_gps_data(timeout_ms=2000):
    start_time = ticks_ms()
    buffer = ""
    
    while ticks_diff(ticks_ms(), start_time) < timeout_ms:
        if uart.any():
            data = uart.read().decode('utf-8', errors='ignore')
            buffer += data
            
            if '\n' in buffer:
                lines = buffer.split('\n')
                for line in lines[:-1]:
                    if parse_nmea_sentence(line):
                        return True
                buffer = lines[-1]
        
        sleep_ms(10)
    
    return False  # Timeout atteint
```

Ce mécanisme permet de maintenir la responsivité du système même en cas de perte temporaire du signal GPS ou de données corrompues.

### 3.1.2 Module Compas (lecture_compas_num.py)

Le compas numérique BMM150 fournit l'orientation nécessaire à la navigation autonome. Son intégration nécessite une configuration I2C spécifique et des corrections de cap.

#### Configuration I2C et détection capteur

L'initialisation du compas s'effectue via l'interface I2C configurée sur les pins 2 et 3 :

```python
class CompassBMM150:
    def __init__(self, sda_pin=2, scl_pin=3, i2c_id=1, address=0x13):
        self.i2c = I2C(i2c_id, sda=Pin(sda_pin), scl=Pin(scl_pin), freq=400000)
        self.address = address
        
        # Vérification présence capteur
        if self.address not in self.i2c.scan():
            raise Exception(f"BMM150 non détecté à l'adresse {hex(self.address)}")
        
        self.initialize_sensor()
```

Cette approche garantit la détection du capteur avant initialisation et lève une exception explicite en cas d'échec, facilitant le débogage.

#### Correction cap et calibration

Le module intègre une correction systématique du cap de -90° pour compenser l'orientation physique du capteur sur le robot :

```python
def lire_cap(self):
    try:
        # Lecture des données magnétiques brutes
        raw_data = self.read_magnetic_data()
        if not raw_data:
            return None
        
        x, y, z = raw_data
        
        # Calcul de l'angle magnétique
        angle = math.atan2(y, x)
        bearing = math.degrees(angle)
        
        # Normalisation 0-360°
        if bearing < 0:
            bearing += 360
        
        # Correction orientation capteur (-90°)
        corrected_bearing = (bearing - 90) % 360
        
        return corrected_bearing
    
    except Exception as e:
        print(f"Erreur lecture compas: {e}")
        return None
```

Cette correction est essentielle pour aligner les mesures du compas avec l'orientation réelle du robot.

#### Gestion des erreurs de lecture

Le module implémente une stratégie de retry avec filtrage des valeurs aberrantes :

```python
def get_stable_reading(self, nb_samples=5, max_retries=3):
    readings = []
    retries = 0
    
    while len(readings) < nb_samples and retries < max_retries:
        cap = self.lire_cap()
        if cap is not None:
            readings.append(cap)
        else:
            retries += 1
            sleep(0.1)
    
    if len(readings) >= 3:
        # Filtrage médian pour éliminer les valeurs aberrantes
        readings.sort()
        return readings[len(readings)//2]
    
    return None
```

Cette approche améliore la fiabilité des mesures en moyennant plusieurs lectures et en filtrant les valeurs incohérentes.

## 3.2 Système de navigation automatique

### 3.2.1 Algorithme ray casting pour polygone GPS

L'algorithme ray-casting implémenté dans `utils.py` détermine si le robot se trouve à l'intérieur du polygone de navigation défini par l'utilisateur :

```python
def is_point_in_polygon(lat, lon, polygon):
    """
    Algorithme ray-casting optimisé pour la détection d'inclusion
    dans un polygone défini par des coordonnées GPS
    """
    if not polygon:
        return False
    
    num_points = len(polygon)
    inside = False
    x, y = lat, lon
    
    j = num_points - 1
    for i in range(num_points):
        xi, yi = polygon[i]
        xj, yj = polygon[j]
        
        # Test d'intersection du rayon avec l'arête
        if ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi):
            inside = not inside
        j = i
    
    return inside
```

Cet algorithme projette un rayon horizontal depuis la position du robot et compte les intersections avec les arêtes du polygone. Un nombre impair d'intersections indique que le point est à l'intérieur.

### 3.2.2 Calcul de cap et correction trajectoire

Le système calcule le cap nécessaire pour rejoindre un point cible en utilisant la formule du bearing géographique :

```python
def calculate_cap(lat1, lon1, lat2, lon2):
    """
    Calcul du cap géographique entre deux points GPS
    Retourne l'angle en degrés (0-360°)
    """
    delta_lon = lon2 - lon1
    delta_lat = lat2 - lat1
    
    # Calcul de l'angle avec correction géographique
    angle = math.atan2(delta_lon, delta_lat)
    bearing = (math.degrees(angle) + 360) % 360
    
    return bearing
```

La correction de trajectoire s'effectue ensuite par comparaison entre le cap calculé et l'orientation actuelle :

```python
def correct_trajectory(current_heading, target_heading, threshold=10):
    """
    Détermine la correction à appliquer pour atteindre le cap cible
    """
    # Calcul de la différence angulaire avec gestion du passage 0°/360°
    diff = (target_heading - current_heading + 540) % 360 - 180
    
    if abs(diff) <= threshold:
        return "forward"  # Trajectoire correcte
    elif diff > 0:
        return "left"     # Tourner à gauche
    else:
        return "right"    # Tourner à droite
```

### 3.2.3 Gestion retour en zone

Lorsque le robot sort du polygone défini, le système calcule automatiquement le point le plus proche sur le périmètre :

```python
def find_closest_point_polygon(lat, lon, polygon):
    """
    Trouve le point le plus proche sur le périmètre du polygone
    pour le retour en zone autorisée
    """
    if not polygon:
        return None
    
    closest_point = None
    min_distance = float('inf')
    num_points = len(polygon)
    
    for i in range(num_points):
        # Points de l'arête courante
        ax, ay = polygon[i]
        bx, by = polygon[(i + 1) % num_points]
        
        # Projection du point sur l'arête
        candidate_point = closest_point_on_segment(lat, lon, ax, ay, bx, by)
        candidate_distance = distance((lat, lon), candidate_point)
        
        if candidate_distance < min_distance:
            min_distance = candidate_distance
            closest_point = candidate_point
    
    return closest_point
```

Cette fonction garantit que le robot emprunte toujours le chemin le plus court pour revenir dans la zone autorisée.

## 3.3 Cycles fonctionnels

### 3.3.1 Cycle de ramassage

Le cycle de ramassage implémenté dans `cycle_rammassage.py` orchestre la séquence complète de récupération d'un objet métallique :

```python
def cycle_rammassage(pin_EA, MoteurPAP, RobotMoteurs):
    """
    Cycle complet de ramassage d'un objet métallique détecté
    1. Positionnement du système de ramassage
    2. Activation électro-aimant
    3. Approche de l'objet
    4. Récupération et remontée
    """
    try:
        moteur = MoteurPAP
        robot = RobotMoteurs
        ea = pin_EA
        
        print("Initialisation cycle ramassage...")
        
        # Phase 1: Descente du système de ramassage
        moteur.set_step_mode("full")
        moteur.tourner_angle(15, delay=0.02, direction=-1)
        
        # Phase 2: Activation électro-aimant et approche
        ea.value(1)  # Activation électro-aimant
        robot.avancer()
        sleep(4)  # Temps d'approche et de contact
        
        # Phase 3: Remontée avec objet
        moteur.tourner_angle(35, delay=0.02, direction=1)
        ea.value(0)  # Désactivation électro-aimant
        
        # Phase 4: Finalisation
        sleep(1)
        moteur.stop()
        
        print("Cycle ramassage terminé avec succès")
        return True
        
    except Exception as e:
        print(f"Erreur lors du cycle de ramassage: {e}")
        # Sécurisation en cas d'erreur
        ea.value(0)
        moteur.stop()
        robot.stop()
        return False
```

Ce cycle intègre une gestion d'erreur robuste avec remise en état sécurisé des actionneurs en cas de problème.

### 3.3.2 Cycle d'évitement d'obstacles

Le système d'évitement implémenté dans `cycle_evite_obstacle.py` utilise une stratégie aléatoire pour contourner les obstacles :

```python
def cycle_evitement(CapteurObstacle, RobotMoteurs):
    """
    Cycle d'évitement d'obstacle avec stratégie aléatoire
    1. Recul pour créer un espace de manœuvre
    2. Rotation aléatoire jusqu'à trouver un passage libre
    3. Avancement pour contourner l'obstacle
    """
    # Phase 1: Recul de sécurité
    RobotMoteurs.reculer()
    sleep(0.5)
    RobotMoteurs.stop()
    sleep(0.2)
    
    # Phase 2: Recherche d'un passage libre
    direction = random.choice(['gauche', 'droite'])
    if direction == 'gauche':
        RobotMoteurs.gauche()
    else:
        RobotMoteurs.droite()
    
    # Rotation jusqu'à détection d'un passage libre (> 50cm)
    while True:
        dist = CapteurObstacle.mesure_distance()
        if dist is not None and dist > 50:
            break
        sleep(0.1)  # Attente entre mesures
    
    RobotMoteurs.stop()
    sleep(0.2)
    
    # Phase 3: Contournement de l'obstacle
    RobotMoteurs.avancer()
    sleep(1.5)  # Temps d'avancement pour contourner
    RobotMoteurs.stop()
```

Cette approche simple mais efficace permet d'éviter la plupart des obstacles en privilégiant une stratégie de contournement aléatoire.

### 3.3.3 Cycle de vidange

Le cycle de vidange du bac collecteur utilise un servomoteur pour ouvrir et fermer la trappe de vidange :

```python
def cycle_vider_bac(servo):
    """
    Cycle de vidange du bac collecteur
    1. Ouverture progressive de la trappe
    2. Maintien ouvert pour vidange complète
    3. Fermeture progressive
    """
    try:
        print("Début cycle vidange...")
        
        # Phase 1: Ouverture trappe
        servo.descendre()  # Ouverture progressive avec PWM
        sleep(2)           # Maintien ouvert pour vidange
        
        # Phase 2: Fermeture trappe
        servo.monter()     # Fermeture progressive
        
        print("Cycle vidange terminé")
        
    except KeyboardInterrupt:
        print("Opération interrompue par l'utilisateur")
    finally:
        servo.stop()  # Désactivation PWM pour économie énergie
        print("Servo désactivé")
```

Le contrôle progressif du servomoteur évite les chocs mécaniques et assure une vidange complète du bac.

## 3.4 Optimisations et gestion mémoire

### 3.4.1 Stratégies de garbage collection

Compte tenu des limitations mémoire du Raspberry Pi Pico (264 KB de RAM), des stratégies spécifiques de gestion mémoire ont été implémentées :

```python
# Configuration garbage collector agressive
gc.threshold(gc.mem_free() // 4 + gc.mem_alloc())

# Nettoyage systématique dans les boucles critiques
def optimized_loop():
    while True:
        # Traitement des données
        process_sensor_data()
        
        # Nettoyage mémoire périodique
        gc.collect()
        
        # Contrôle mémoire critique
        if gc.mem_free() < 10000:  # Seuil critique 10KB
            print("Mémoire critique, nettoyage forcé")
            cleanup_variables()
            gc.collect()
```

### 3.4.2 Optimisation des structures de données

Les structures de données ont été optimisées pour minimiser l'empreinte mémoire :

```python
# Utilisation de listes au lieu de dictionnaires quand possible
robot_state = ["manuel", 75, True]  # [mode, battery, power]
robot_position = [None, None]       # [latitude, longitude]

# Réutilisation d'objets plutôt que création/destruction
def create_json_response(data, status=200):
    json_str = json.dumps(data)
    del data  # Libération immédiate
    gc.collect()
    return Response(json_str, status, {'Content-Type': 'application/json'})
```

Cette approche permet de maintenir les fonctionnalités tout en respectant les contraintes mémoire du microcontrôleur.

## 3.5 Integration et synchronisation

### 3.5.1 Coordination des modules

L'intégration des différents modules s'effectue via une architecture événementielle avec gestion des priorités :

```python
def main_control_loop():
    """
    Boucle principale de contrôle avec gestion des priorités
    """
    while True:
        # Priorité 1: Sécurité (obstacles)
        if obstacle_detected():
            handle_obstacle_avoidance()
            continue
        
        # Priorité 2: Mission (détection métal)
        if metal_detected:
            handle_metal_collection()
            continue
        
        # Priorité 3: Navigation normale
        handle_navigation()
        
        # Maintenance système
        system_maintenance()
```

### 3.5.2 Gestion des états système

Un système d'états coordonne les différents modes de fonctionnement :

```python
class SystemState:
    MANUAL = "manuel"
    AUTO = "auto"
    COLLECTING = "ramassage"
    AVOIDING = "evitement"
    ERROR = "erreur"

def state_machine_handler(current_state, event):
    """
    Machine à états pour la coordination des modes
    """
    transitions = {
        (SystemState.MANUAL, "auto_requested"): SystemState.AUTO,
        (SystemState.AUTO, "metal_detected"): SystemState.COLLECTING,
        (SystemState.AUTO, "obstacle_detected"): SystemState.AVOIDING,
        (SystemState.COLLECTING, "cycle_complete"): SystemState.AUTO,
        (SystemState.AVOIDING, "path_clear"): SystemState.AUTO,
    }
    
    return transitions.get((current_state, event), current_state)
```

Cette architecture garantit une transition cohérente entre les différents modes de fonctionnement du robot.

---

Cette implémentation du code embarqué démontre une approche structurée du développement pour systèmes contraints, intégrant gestion des capteurs, algorithmes de navigation et optimisations mémoire spécifiques au Raspberry Pi Pico WH.